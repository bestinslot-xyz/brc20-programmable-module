use std::error::Error;

use alloy::primitives::{logs_bloom, Log};
use serde::{Deserialize, Serialize};

use crate::db::types::{AddressED, Decode, Encode, LogED, B2048ED, B256ED, U64ED, U8ED};
use crate::types::BytesED;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
/// Represents a transaction receipt from the EVM.
///
/// Refer to [Ethereum JSON-RPC documentation on eth_getTransactionReceipt](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) for more details.
pub struct TxReceiptED {
    /// The status of the transaction, 1 for success, 0 for failure
    pub status: U8ED,
    /// The logs generated by the transaction
    pub logs: Vec<LogED>,
    #[serde(rename = "gasUsed")]
    /// The amount of gas used by the transaction
    pub gas_used: U64ED,
    /// The address of the sender
    pub from: AddressED,
    /// The address of the recipient, empty if the transaction is a contract creation
    pub to: Option<AddressED>,
    #[serde(rename = "contractAddress")]
    /// The address of the contract created by the transaction, empty if not applicable
    pub contract_address: Option<AddressED>,
    #[serde(rename = "logsBloom")]
    /// The bloom filter for the logs generated by the transaction
    pub logs_bloom: B2048ED,
    #[serde(rename = "blockHash")]
    /// The hash of the block that contains the transaction
    pub block_hash: B256ED,
    #[serde(rename = "blockNumber")]
    /// The number of the block that contains the transaction
    pub block_number: U64ED,
    #[serde(rename = "transactionHash")]
    /// The hash of the transaction
    pub transaction_hash: B256ED,
    #[serde(rename = "transactionIndex")]
    /// The index of the transaction in the block
    pub transaction_index: U64ED,
    #[serde(rename = "cumulativeGasUsed")]
    /// The cumulative amount of gas used by all transactions in the block
    pub cumulative_gas_used: U64ED,
    #[serde(rename = "effectiveGasPrice")]
    /// The effective gas price for the transaction, 0 for BRC2.0
    pub effective_gas_price: U64ED,
    #[serde(rename = "type")]
    /// The type of the transaction, always 0 for BRC2.0
    pub transaction_type: U8ED,
}

impl TxReceiptED {
    // This is returned by the API, so doesn't need to be public
    pub(crate) fn new(
        block_hash: B256ED,
        block_number: U64ED,
        contract_address: Option<AddressED>,
        from: AddressED,
        to: Option<AddressED>,
        transaction_hash: B256ED,
        transaction_index: U64ED,
        is_success: bool,
        logs: &Vec<Log>,
        gas_used: u64,
        cumulative_gas_used: U64ED,
        start_log_index: U64ED,
    ) -> Result<Self, Box<dyn Error>> {
        Ok(TxReceiptED {
            status: (is_success as u8).into(),
            logs: LogED::new_vec(
                &logs,
                start_log_index.into(),
                transaction_index,
                transaction_hash,
                block_hash,
                block_number,
            ),
            gas_used: gas_used.into(),
            from,
            to,
            contract_address,
            logs_bloom: B2048ED::decode_vec(&logs_bloom(logs).to_vec())?,
            block_hash,
            block_number,
            transaction_hash,
            transaction_index,
            cumulative_gas_used,
            effective_gas_price: 0u64.into(),
            transaction_type: 0u8.into(),
        })
    }
}

impl Encode for TxReceiptED {
    fn encode(&self, buffer: &mut Vec<u8>) {
        self.status.encode(buffer);
        String::new().encode(buffer); // Legacy for tx result
        String::new().encode(buffer); // Legacy for reason
        self.logs.encode(buffer);
        self.gas_used.encode(buffer);
        self.from.encode(buffer);
        self.to.encode(buffer);
        self.contract_address.encode(buffer);
        self.logs_bloom.encode(buffer);
        self.block_hash.encode(buffer);
        self.block_number.encode(buffer);
        U64ED::zero().encode(buffer); // Legacy for block timestamp
        self.transaction_hash.encode(buffer);
        self.transaction_index.encode(buffer);
        self.cumulative_gas_used.encode(buffer);
        U64ED::zero().encode(buffer); // Legacy for nonce
        Option::<BytesED>::None.encode(buffer); // Legacy for result bytes
    }
}

impl Decode for TxReceiptED {
    fn decode(bytes: &[u8], offset: usize) -> Result<(Self, usize), Box<dyn Error>> {
        let (status, offset) = Decode::decode(bytes, offset)?;
        let (_type, offset) = String::decode(bytes, offset)?; // Legacy, ignore
        let (_reason, offset) = String::decode(bytes, offset)?; // Legacy, ignore
        let (logs, offset) = Decode::decode(bytes, offset)?;
        let (gas_used, offset) = Decode::decode(bytes, offset)?;
        let (from, offset) = Decode::decode(bytes, offset)?;
        let (to, offset) = Decode::decode(bytes, offset)?;
        let (contract_address, offset) = Decode::decode(bytes, offset)?;
        let (logs_bloom, offset) = Decode::decode(bytes, offset)?;
        let (block_hash, offset) = Decode::decode(bytes, offset)?;
        let (block_number, offset) = Decode::decode(bytes, offset)?;
        let (_block_timestamp, offset) = U64ED::decode(bytes, offset)?; // Legacy, ignore
        let (transaction_hash, offset) = Decode::decode(bytes, offset)?;
        let (transaction_index, offset) = Decode::decode(bytes, offset)?;
        let (cumulative_gas_used, offset) = Decode::decode(bytes, offset)?;
        let (_nonce, offset) = U64ED::decode(bytes, offset)?; // Legacy, ignore
        let (_result_bytes, offset) = <Option<BytesED>>::decode(bytes, offset)?; // Legacy, ignore
        Ok((
            TxReceiptED {
                status,
                logs,
                gas_used,
                from,
                to,
                contract_address,
                logs_bloom,
                block_hash,
                block_number,
                transaction_hash,
                transaction_index,
                cumulative_gas_used,
                effective_gas_price: 0u64.into(),
                transaction_type: 0u8.into(),
            },
            offset,
        ))
    }
}

#[cfg(test)]
mod tests {
    use revm::primitives::LogData;

    use super::*;

    #[test]
    fn test_tx_receipt_ed() {
        let tx_receipt_ed = TxReceiptED::new(
            [10u8; 32].into(),      // block_hash
            11u64.into(),           // block_number
            Some([8u8; 20].into()), // contract_address
            [6u8; 20].into(),       // from
            Some([7u8; 20].into()), // to
            [12u8; 32].into(),      // transaction_hash
            13u64.into(),           // transaction_index
            true,                   // is_success (arbitrary, since status was 4u8 before)
            &vec![Log {
                address: [1u8; 20].into(),
                data: LogData::new(
                    vec![[2u8; 32].into(), [3u8; 32].into()],
                    vec![4u8; 32].into(),
                )
                .expect("Failed to create LogData"),
            }],
            5u64,         // gas_used
            14u64.into(), // cumulative_gas_used
            0u64.into(),  // start_log_index (arbitrary for test)
        )
        .unwrap();
        let bytes = tx_receipt_ed.encode_vec();
        let decoded = TxReceiptED::decode_vec(&bytes).unwrap();
        assert_eq!(tx_receipt_ed, decoded);
    }

    #[test]
    fn test_tx_receipt_ed_serde() {
        let tx_receipt_ed = TxReceiptED::new(
            [10u8; 32].into(),      // block_hash
            11u64.into(),           // block_number
            Some([8u8; 20].into()), // contract_address
            [6u8; 20].into(),       // from
            Some([7u8; 20].into()), // to
            [12u8; 32].into(),      // transaction_hash
            13u64.into(),           // transaction_index
            true,                   // is_success (arbitrary, since status was 4u8 before)
            &vec![Log {
                address: [1u8; 20].into(),
                data: LogData::new(
                    vec![[2u8; 32].into(), [3u8; 32].into()],
                    vec![4u8; 32].into(),
                )
                .expect("Failed to create LogData"),
            }],
            5u64,         // gas_used
            14u64.into(), // cumulative_gas_used
            0u64.into(),  // start_log_index (arbitrary for test)
        )
        .unwrap();
        let serialized = serde_json::to_string(&tx_receipt_ed).unwrap();
        let deserialized: TxReceiptED = serde_json::from_str(&serialized).unwrap();
        assert_eq!(tx_receipt_ed, deserialized);
    }

    #[test]
    fn test_legacy_fields() {
        let tx_receipt_ed = TxReceiptED::new(
            [10u8; 32].into(),      // block_hash
            11u64.into(),           // block_number
            Some([8u8; 20].into()), // contract_address
            [6u8; 20].into(),       // from
            Some([7u8; 20].into()), // to
            [12u8; 32].into(),      // transaction_hash
            13u64.into(),           // transaction_index
            true,                   // is_success (arbitrary, since status was 4u8 before)
            &vec![Log {
                address: [1u8; 20].into(),
                data: LogData::new(
                    vec![[2u8; 32].into(), [3u8; 32].into()],
                    vec![4u8; 32].into(),
                )
                .expect("Failed to create LogData"),
            }],
            5u64,         // gas_used
            14u64.into(), // cumulative_gas_used
            0u64.into(),  // start_log_index (arbitrary for test)
        )
        .unwrap();

        // This is a hex dump of the encoded struct, including legacy fields from a previous version
        // This is to ensure backward compatibility with previously stored data
        // Future major versions can remove legacy fields and this test can be deleted
        let encoded_hex = "000000000000000100000000000000000000000101010101010101010101010101010101010101010000000202020202020202020202020202020202020202020202020202020202020202020303030303030303030303030303030303030303030303030303030303030303000000200404040404040404040404040404040404040404040404040404040404040404000000000000000d0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a000000000000000b000000000000000000000000000000050606060606060606060606060606060606060606010707070707070707070707070707070707070707010808080808080808080808080808080808080808000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000800800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000004000000000020000000000000000000000000000000000000000000000000000000002000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a000000000000000b00000000000000000c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c000000000000000d000000000000000e000000000000000000";
        let decoded = TxReceiptED::decode_vec(&hex::decode(encoded_hex).unwrap()).unwrap();

        assert_eq!(tx_receipt_ed, decoded);
    }
}
