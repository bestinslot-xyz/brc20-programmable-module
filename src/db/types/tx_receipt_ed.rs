use std::error::Error;
use alloy_primitives::{logs_bloom, Log};

use serde::{Deserialize, Serialize};

use crate::db::types::{AddressED, BytesED, Decode, Encode, LogED, B2048ED, B256ED, U64ED, U8ED};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
/// Represents a transaction receipt from the EVM.
///
/// Refer to [Ethereum JSON-RPC documentation on eth_getTransactionReceipt](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) for more details.
pub struct TxReceiptED {
    /// The status of the transaction, 1 for success, 0 for failure
    pub status: U8ED,
    #[serde(rename = "txResult")]
    /// The result of the transaction, "Success", "Revert" or "Halt"
    pub transaction_result: String,
    #[serde(rename = "reason")]
    /// The reason for the transaction result, from a list of possible reasons
    /// (e.g., "OutOfGas", "Revert", etc.)
    pub reason: String,
    /// The logs generated by the transaction
    pub logs: Vec<LogED>,
    #[serde(rename = "gasUsed")]
    /// The amount of gas used by the transaction
    pub gas_used: U64ED,
    /// The address of the sender
    pub from: AddressED,
    /// The address of the recipient, empty if the transaction is a contract creation
    pub to: Option<AddressED>,
    #[serde(rename = "contractAddress")]
    /// The address of the contract created by the transaction, empty if not applicable
    pub contract_address: Option<AddressED>,
    #[serde(rename = "logsBloom")]
    /// The bloom filter for the logs generated by the transaction
    pub logs_bloom: B2048ED,
    #[serde(rename = "blockHash")]
    /// The hash of the block that contains the transaction
    pub block_hash: B256ED,
    #[serde(rename = "blockNumber")]
    /// The number of the block that contains the transaction
    pub block_number: U64ED,
    #[serde(rename = "blockTimestamp")]
    /// The timestamp of the block that contains the transaction
    pub block_timestamp: U64ED,
    #[serde(rename = "transactionHash")]
    /// The hash of the transaction
    pub transaction_hash: B256ED,
    #[serde(rename = "transactionIndex")]
    /// The index of the transaction in the block
    pub transaction_index: U64ED,
    #[serde(rename = "cumulativeGasUsed")]
    /// The cumulative amount of gas used by all transactions in the block
    pub cumulative_gas_used: U64ED,
    #[serde(rename = "effectiveGasPrice")]
    /// The effective gas price for the transaction, 0 for BRC2.0
    pub effective_gas_price: U64ED,
    #[serde(rename = "type")]
    /// The type of the transaction, always 0 for BRC2.0
    pub transaction_type: U8ED,
    /// The nonce of the transaction
    pub nonce: U64ED,
    #[serde(rename = "output")]
    /// The output data from the transaction, if applicable, return value of the call, if any
    /// (e.g., the return value of a smart contract function call)
    pub result_bytes: Option<BytesED>,
}


impl TxReceiptED {
    // This is returned by the API, so doesn't need to be public
    pub(crate) fn new(
        block_hash: B256ED,
        block_number: U64ED,
        block_timestamp: U64ED,
        contract_address: Option<AddressED>,
        from: AddressED,
        to: Option<AddressED>,
        transaction_hash: B256ED,
        transaction_index: U64ED,
        is_success: bool,
        logs: &Vec<Log>,
        gas_used: u64,
        cumulative_gas_used: U64ED,
        nonce: U64ED,
        start_log_index: U64ED,
        r#type: String,
        reason: String,
        result_bytes: Option<BytesED>,
    ) -> Result<Self, Box<dyn Error>> {
        Ok(TxReceiptED {
            status: (is_success as u8).into(),
            transaction_result: r#type,
            reason,
            logs: LogED::new_vec(
                &logs,
                start_log_index.into(),
                transaction_index,
                transaction_hash,
                block_hash,
                block_number,
            ),
            gas_used: gas_used.into(),
            from,
            to,
            contract_address,
            logs_bloom: B2048ED::decode_vec(&logs_bloom(logs).to_vec())?,
            block_hash,
            block_number,
            block_timestamp,
            transaction_hash,
            transaction_index,
            cumulative_gas_used,
            nonce,
            result_bytes,
            effective_gas_price: 0u64.into(),
            transaction_type: 0u8.into(),
        })
    }
}

impl Encode for TxReceiptED {
    fn encode(&self, buffer: &mut Vec<u8>) {
        self.status.encode(buffer);
        self.transaction_result.encode(buffer);
        self.reason.encode(buffer);
        self.logs.encode(buffer);
        self.gas_used.encode(buffer);
        self.from.encode(buffer);
        self.to.encode(buffer);
        self.contract_address.encode(buffer);
        self.logs_bloom.encode(buffer);
        self.block_hash.encode(buffer);
        self.block_number.encode(buffer);
        self.block_timestamp.encode(buffer);
        self.transaction_hash.encode(buffer);
        self.transaction_index.encode(buffer);
        self.cumulative_gas_used.encode(buffer);
        self.nonce.encode(buffer);
        self.result_bytes.encode(buffer);
    }
}

impl Decode for TxReceiptED {
    fn decode(bytes: &[u8], offset: usize) -> Result<(Self, usize), Box<dyn Error>> {
        let (status, offset) = Decode::decode(bytes, offset)?;
        let (r#type, offset) = Decode::decode(bytes, offset)?;
        let (reason, offset) = Decode::decode(bytes, offset)?;
        let (logs, offset) = Decode::decode(bytes, offset)?;
        let (gas_used, offset) = Decode::decode(bytes, offset)?;
        let (from, offset) = Decode::decode(bytes, offset)?;
        let (to, offset) = Decode::decode(bytes, offset)?;
        let (contract_address, offset) = Decode::decode(bytes, offset)?;
        let (logs_bloom, offset) = Decode::decode(bytes, offset)?;
        let (block_hash, offset) = Decode::decode(bytes, offset)?;
        let (block_number, offset) = Decode::decode(bytes, offset)?;
        let (block_timestamp, offset) = Decode::decode(bytes, offset)?;
        let (transaction_hash, offset) = Decode::decode(bytes, offset)?;
        let (transaction_index, offset) = Decode::decode(bytes, offset)?;
        let (cumulative_gas_used, offset) = Decode::decode(bytes, offset)?;
        let (nonce, offset) = Decode::decode(bytes, offset)?;
        let (result_bytes, offset) = Decode::decode(bytes, offset)?;
        Ok((
            TxReceiptED {
                status,
                transaction_result: r#type,
                reason,
                logs,
                gas_used,
                from,
                to,
                contract_address,
                logs_bloom,
                block_hash,
                block_number,
                block_timestamp,
                transaction_hash,
                transaction_index,
                cumulative_gas_used,
                effective_gas_price: 0u64.into(),
                transaction_type: 0u8.into(),
                nonce,
                result_bytes,
            },
            offset,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tx_receipt_ed() {
        let logs = LogED {
            address: [1u8; 20].into(),
            topics: vec![[2u8; 32].into(), [3u8; 32].into()],
            data: BytesED::from([4u8; 32].to_vec()),
            transaction_index: 5u64.into(),
            transaction_hash: [6u8; 32].into(),
            block_hash: [7u8; 32].into(),
            block_number: 8u64.into(),
            log_index: 9u64.into(),
        };
        let tx_receipt_ed = TxReceiptED {
            status: 4u8.into(),
            transaction_result: "type".to_string(),
            reason: "reason".to_string(),
            logs: vec![logs],
            gas_used: 5u64.into(),
            from: [6u8; 20].into(),
            to: Some([7u8; 20].into()),
            contract_address: Some([8u8; 20].into()),
            logs_bloom: [9u8; 256].into(),
            block_hash: [10u8; 32].into(),
            block_number: 11u64.into(),
            block_timestamp: 12u64.into(),
            transaction_hash: [12u8; 32].into(),
            transaction_index: 13u64.into(),
            cumulative_gas_used: 14u64.into(),
            nonce: 15u64.into(),
            result_bytes: None,
            effective_gas_price: 0u64.into(),
            transaction_type: 0u8.into(),
        };
        let bytes = tx_receipt_ed.encode_vec();
        let decoded = TxReceiptED::decode_vec(&bytes).unwrap();
        assert_eq!(tx_receipt_ed, decoded);
    }

    #[test]
    fn test_tx_receipt_ed_serde() {
        let logs = LogED {
            address: [1u8; 20].into(),
            topics: vec![[2u8; 32].into(), [3u8; 32].into()],
            data: BytesED::from([4u8; 32].to_vec()),
            transaction_index: 5u64.into(),
            transaction_hash: [6u8; 32].into(),
            block_hash: [7u8; 32].into(),
            block_number: 8u64.into(),
            log_index: 9u64.into(),
        };
        let tx_receipt_ed = TxReceiptED {
            status: 4u8.into(),
            transaction_result: "type".to_string(),
            reason: "reason".to_string(),
            logs: vec![logs],
            gas_used: 5u64.into(),
            from: [6u8; 20].into(),
            to: Some([7u8; 20].into()),
            contract_address: Some([8u8; 20].into()),
            logs_bloom: [9u8; 256].into(),
            block_hash: [10u8; 32].into(),
            block_number: 11u64.into(),
            block_timestamp: 12u64.into(),
            transaction_hash: [12u8; 32].into(),
            transaction_index: 13u64.into(),
            cumulative_gas_used: 14u64.into(),
            nonce: 15u64.into(),
            result_bytes: None,
            effective_gas_price: 0u64.into(),
            transaction_type: 0u8.into(),
        };
        let serialized = serde_json::to_string(&tx_receipt_ed).unwrap();
        let deserialized: TxReceiptED = serde_json::from_str(&serialized).unwrap();
        assert_eq!(tx_receipt_ed, deserialized);
    }
}
