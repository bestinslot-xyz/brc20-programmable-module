use std::error::Error;

use alloy::primitives::{logs_bloom, Log};
use serde::{Deserialize, Serialize};

use crate::db::types::{AddressED, Decode, Encode, LogED, B2048ED, B256ED, U64ED, U8ED};
use crate::types::BytesED;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
/// Represents a transaction receipt from the EVM.
///
/// Refer to [Ethereum JSON-RPC documentation on eth_getTransactionReceipt](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt) for more details.
pub struct TxReceiptED {
    /// The status of the transaction, 1 for success, 0 for failure
    pub status: U8ED,
    /// The logs generated by the transaction
    pub logs: Vec<LogED>,
    #[serde(rename = "gasUsed")]
    /// The amount of gas used by the transaction
    pub gas_used: U64ED,
    /// The address of the sender
    pub from: AddressED,
    /// The address of the recipient, empty if the transaction is a contract creation
    pub to: Option<AddressED>,
    #[serde(rename = "contractAddress")]
    /// The address of the contract created by the transaction, empty if not applicable
    pub contract_address: Option<AddressED>,
    #[serde(rename = "logsBloom")]
    /// The bloom filter for the logs generated by the transaction
    pub logs_bloom: B2048ED,
    #[serde(rename = "blockHash")]
    /// The hash of the block that contains the transaction
    pub block_hash: B256ED,
    #[serde(rename = "blockNumber")]
    /// The number of the block that contains the transaction
    pub block_number: U64ED,
    #[serde(rename = "transactionHash")]
    /// The hash of the transaction
    pub transaction_hash: B256ED,
    #[serde(rename = "transactionIndex")]
    /// The index of the transaction in the block
    pub transaction_index: U64ED,
    #[serde(rename = "cumulativeGasUsed")]
    /// The cumulative amount of gas used by all transactions in the block
    pub cumulative_gas_used: U64ED,
    #[serde(rename = "effectiveGasPrice")]
    /// The effective gas price for the transaction, 0 for BRC2.0
    pub effective_gas_price: U64ED,
    #[serde(rename = "type")]
    /// The type of the transaction, always 0 for BRC2.0
    pub transaction_type: U8ED,

    // Legacy fields required by the API
    #[serde(rename = "blockTimestamp", default = "U64ED::zero", skip_deserializing)]
    /// The timestamp of the block that contains the transaction
    pub _block_timestamp: U64ED,
    #[serde(rename = "nonce", default = "U64ED::zero", skip_deserializing)]
    /// The nonce of the transaction
    pub _nonce: U64ED,
    #[serde(rename = "output", default = "Option::default", skip_deserializing)]
    /// The output data from the transaction, if applicable, return value of the call, if any
    /// (e.g., the return value of a smart contract function call)
    pub _result_bytes: Option<BytesED>,
    #[serde(rename = "txResult", default = "String::new", skip_deserializing)]
    /// The result of the transaction, "Success", "Revert" or "Halt"
    pub _transaction_result: String,
    #[serde(rename = "reason", default = "String::new", skip_deserializing)]
    /// The reason for the transaction result, from a list of possible reasons
    /// (e.g., "OutOfGas", "Revert", etc.)
    pub _reason: String,
}

impl TxReceiptED {
    // This is returned by the API, so doesn't need to be public
    pub(crate) fn new(
        block_hash: B256ED,
        block_number: U64ED,
        contract_address: Option<AddressED>,
        from: AddressED,
        to: Option<AddressED>,
        transaction_hash: B256ED,
        transaction_index: U64ED,
        is_success: bool,
        logs: &Vec<Log>,
        gas_used: u64,
        cumulative_gas_used: U64ED,
        start_log_index: U64ED,
    ) -> Result<Self, Box<dyn Error>> {
        Ok(TxReceiptED {
            status: (is_success as u8).into(),
            logs: LogED::new_vec(
                &logs,
                start_log_index.into(),
                transaction_index,
                transaction_hash,
                block_hash,
                block_number,
            ),
            gas_used: gas_used.into(),
            from,
            to,
            contract_address,
            logs_bloom: B2048ED::decode_vec(&logs_bloom(logs).to_vec())?,
            block_hash,
            block_number,
            transaction_hash,
            transaction_index,
            cumulative_gas_used,
            effective_gas_price: 0u64.into(),
            transaction_type: 0u8.into(),
            _block_timestamp: 0u64.into(),       // Legacy
            _nonce: 0u64.into(),                 // Legacy
            _result_bytes: None,                 // Legacy
            _transaction_result: "".to_string(), // Legacy
            _reason: "".to_string(),             // Legacy
        })
    }
}

impl Encode for TxReceiptED {
    fn encode(&self, buffer: &mut Vec<u8>) {
        self.status.encode(buffer);
        self._transaction_result.encode(buffer); // Legacy
        self._reason.encode(buffer); // Legacy
        self.logs.encode(buffer);
        self.gas_used.encode(buffer);
        self.from.encode(buffer);
        self.to.encode(buffer);
        self.contract_address.encode(buffer);
        self.logs_bloom.encode(buffer);
        self.block_hash.encode(buffer);
        self.block_number.encode(buffer);
        self._block_timestamp.encode(buffer); // Legacy
        self.transaction_hash.encode(buffer);
        self.transaction_index.encode(buffer);
        self.cumulative_gas_used.encode(buffer);
        self._nonce.encode(buffer); // Legacy
        self._result_bytes.encode(buffer); // Legacy
    }
}

impl Decode for TxReceiptED {
    fn decode(bytes: &[u8], offset: usize) -> Result<(Self, usize), Box<dyn Error>> {
        let (status, offset) = Decode::decode(bytes, offset)?;
        let (r#type, offset) = Decode::decode(bytes, offset)?;
        let (reason, offset) = Decode::decode(bytes, offset)?;
        let (logs, offset) = Decode::decode(bytes, offset)?;
        let (gas_used, offset) = Decode::decode(bytes, offset)?;
        let (from, offset) = Decode::decode(bytes, offset)?;
        let (to, offset) = Decode::decode(bytes, offset)?;
        let (contract_address, offset) = Decode::decode(bytes, offset)?;
        let (logs_bloom, offset) = Decode::decode(bytes, offset)?;
        let (block_hash, offset) = Decode::decode(bytes, offset)?;
        let (block_number, offset) = Decode::decode(bytes, offset)?;
        let (block_timestamp, offset) = Decode::decode(bytes, offset)?;
        let (transaction_hash, offset) = Decode::decode(bytes, offset)?;
        let (transaction_index, offset) = Decode::decode(bytes, offset)?;
        let (cumulative_gas_used, offset) = Decode::decode(bytes, offset)?;
        let (nonce, offset) = Decode::decode(bytes, offset)?;
        let (result_bytes, offset) = Decode::decode(bytes, offset)?;
        Ok((
            TxReceiptED {
                status,
                _transaction_result: r#type,
                _reason: reason,
                logs,
                gas_used,
                from,
                to,
                contract_address,
                logs_bloom,
                block_hash,
                block_number,
                _block_timestamp: block_timestamp,
                transaction_hash,
                transaction_index,
                cumulative_gas_used,
                effective_gas_price: 0u64.into(),
                transaction_type: 0u8.into(),
                _nonce: nonce,
                _result_bytes: result_bytes,
            },
            offset,
        ))
    }
}

#[cfg(test)]
mod tests {
    use revm::primitives::LogData;

    use super::*;

    #[test]
    fn test_tx_receipt_ed() {
        let tx_receipt_ed = TxReceiptED::new(
            [10u8; 32].into(),      // block_hash
            11u64.into(),           // block_number
            Some([8u8; 20].into()), // contract_address
            [6u8; 20].into(),       // from
            Some([7u8; 20].into()), // to
            [12u8; 32].into(),      // transaction_hash
            13u64.into(),           // transaction_index
            true,                   // is_success (arbitrary, since status was 4u8 before)
            &vec![Log {
                address: [1u8; 20].into(),
                data: LogData::new(
                    vec![[2u8; 32].into(), [3u8; 32].into()],
                    vec![4u8; 32].into(),
                )
                .expect("Failed to create LogData"),
            }],
            5u64,         // gas_used
            14u64.into(), // cumulative_gas_used
            0u64.into(),  // start_log_index (arbitrary for test)
        )
        .unwrap();
        let bytes = tx_receipt_ed.encode_vec();
        let decoded = TxReceiptED::decode_vec(&bytes).unwrap();
        assert_eq!(tx_receipt_ed, decoded);
    }

    #[test]
    fn test_tx_receipt_ed_serde() {
        let tx_receipt_ed = TxReceiptED::new(
            [10u8; 32].into(),      // block_hash
            11u64.into(),           // block_number
            Some([8u8; 20].into()), // contract_address
            [6u8; 20].into(),       // from
            Some([7u8; 20].into()), // to
            [12u8; 32].into(),      // transaction_hash
            13u64.into(),           // transaction_index
            true,                   // is_success (arbitrary, since status was 4u8 before)
            &vec![Log {
                address: [1u8; 20].into(),
                data: LogData::new(
                    vec![[2u8; 32].into(), [3u8; 32].into()],
                    vec![4u8; 32].into(),
                )
                .expect("Failed to create LogData"),
            }],
            5u64,         // gas_used
            14u64.into(), // cumulative_gas_used
            0u64.into(),  // start_log_index (arbitrary for test)
        )
        .unwrap();
        let serialized = serde_json::to_string(&tx_receipt_ed).unwrap();
        let deserialized: TxReceiptED = serde_json::from_str(&serialized).unwrap();
        assert_eq!(tx_receipt_ed, deserialized);
    }
}
