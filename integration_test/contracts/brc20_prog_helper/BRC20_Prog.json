{
    "compiler": {
        "version": "0.8.24+commit.e11b9ed9"
    },
    "language": "Solidity",
    "settings": {
        "compilationTarget": {
            "BRC20_Prog.sol": "BRC20_Prog"
        },
        "evmVersion": "cancun",
        "libraries": {},
        "metadata": {
            "bytecodeHash": "ipfs",
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "remappings": []
    },
    "sources": {
        "BRC20_Prog.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\n/**\n * @dev BRC-20 Prog helper functions.\n */\ncontract BRC20_Prog {\n    address private _btc_locked_pkscript_address =\n        0x00000000000000000000000000000000000000fb;\n    address private _btc_last_sat_loc_address =\n        0x00000000000000000000000000000000000000fc;\n    address private _btc_tx_details_address =\n        0x00000000000000000000000000000000000000fd;\n    address private _bip322_verify_address =\n        0x00000000000000000000000000000000000000fe;\n    address private _brc20_controller_address =\n        0x00000000000000000000000000000000000000ff;\n\n    constructor() {}\n\n    /**\n     * @dev Verifies BIP322 signature, given address, message and the signature.\n     */\n    function verify(\n        bytes calldata pkscript,\n        bytes calldata message,\n        bytes calldata signature\n    ) external view returns (bool verified) {\n        (bool success, bytes memory data) = _bip322_verify_address.staticcall(\n            abi.encodeWithSignature(\n                \"verify(bytes,bytes,bytes)\",\n                pkscript,\n                message,\n                signature\n            )\n        );\n        require(success, \"Failed to verify BIP322 signature\");\n        return abi.decode(data, (bool));\n    }\n\n    /**\n     * @dev Get non-module BRC-20 balance of a given Bitcoin wallet script and BRC-20 ticker.\n     */\n    function balanceOf(\n        bytes calldata ticker,\n        bytes calldata pkscript\n    ) external view returns (uint256 balance) {\n        (bool success, bytes memory data) = _brc20_controller_address\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"balanceOf(bytes,bytes)\",\n                    ticker,\n                    pkscript\n                )\n            );\n        require(success, \"Failed to get BRC20 balance\");\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @dev Get Bitcoin transaction details using tx ids.\n     */\n    function getTxDetails(\n        bytes32 txid\n    )\n        external\n        view\n        returns (\n            uint256 block_height,\n            bytes32[] memory vin_txids,\n            uint256[] memory vin_vouts,\n            bytes[] memory vin_scriptPubKeys,\n            uint256[] memory vin_values,\n            bytes[] memory vout_scriptPubKeys,\n            uint256[] memory vout_values\n        )\n    {\n        (bool success, bytes memory data) = _btc_tx_details_address.staticcall(\n            abi.encodeWithSignature(\"getTxDetails(bytes32)\", txid)\n        );\n        require(success, \"Failed to get transaction details\");\n        return abi.decode(\n                data,\n                (\n                    uint256,\n                    bytes32[],\n                    uint256[],\n                    bytes[],\n                    uint256[],\n                    bytes[],\n                    uint256[]\n                )\n            );\n    }\n\n    /**\n     * @dev Get last satoshi location of a given sat location in a transaction.\n     */\n    function getLastSatLocation(\n        bytes32 txid,\n        uint256 vout,\n        uint256 sat\n    )\n        external\n        view\n        returns (\n            bytes32 last_txid,\n            uint256 last_vout,\n            uint256 last_sat,\n            bytes memory old_pkscript,\n            bytes memory new_pkscript\n        )\n    {\n        (bool success, bytes memory data) = _btc_last_sat_loc_address\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"getLastSatLocation(bytes32,uint256,uint256)\",\n                    txid,\n                    vout,\n                    sat\n                )\n            );\n        require(success, \"Failed to get last satoshi location\");\n        return abi.decode(data, (bytes32, uint256, uint256, bytes, bytes));\n    }\n\n    /**\n     * @dev Get locked pkscript of a given Bitcoin pkscript.\n     */\n    function getLockedPkscript(\n        bytes calldata pkscript,\n        uint256 lock_block_count\n    ) external view returns (bytes memory locked_pkscript) {\n        (bool success, bytes memory data) = _btc_locked_pkscript_address\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"getLockedPkscript(bytes,uint256)\",\n                    pkscript,\n                    lock_block_count\n                )\n            );\n        require(success, \"Failed to get locked pkscript\");\n        return abi.decode(data, (bytes));\n    }\n\n    /**\n     * @dev Sha256 hash of a given message. For testing precompiles.\n     */\n    function getSha256(bytes calldata message) external view returns (bytes32) {\n        (bool success, bytes memory data) = address(0x02).staticcall(abi.encodePacked(message));\n        require(success, \"Failed to get SHA256\");\n        return abi.decode(data, (bytes32));\n    }\n\n    /**\n     * @dev Get random number.\n     */\n    function getRandomNumber() external pure returns (uint256) {\n        return 42;\n    }\n}\n",
            "keccak256": "0x9d12400902f569277589480bab7691cfe089da9c3789ef4fb780244b3a42a2eb",
            "license": "MIT"
        }
    },
    "version": 1
}